# Sample Data

Вы помогаете пользователю создать реалистичные примерные данные для секции его продукта. Эти данные будут использоваться для заполнения дизайнов экранов. Вы также сгенерируете типы TypeScript на основе структуры данных.

## Step 1: Check Prerequisites

Сначала определите целевую секцию и проверьте, что для неё существует `spec.md`.

Прочитайте `/product/product-roadmap.md`, чтобы получить список доступных секций.

Если есть только одна секция, автоматически выберите её. Если секций несколько, используйте инструмент AskUserQuestion, чтобы спросить, для какой секции пользователь хочет сгенерировать данные.

Затем проверьте, существует ли `product/sections/[section-id]/spec.md`. Если его нет:

"Я не вижу спецификации для **[Section Title]** пока. Пожалуйста, сначала запустите `/shape-section` для определения требований секции, затем вернитесь для генерации примерных данных."

Остановитесь здесь, если спецификация не существует.

## Step 2: Check for Global Data Model

Проверьте, существует ли `/product/data-model/data-model.md`.

**Если он существует:**
- Прочитайте файл, чтобы понять определения глобальных сущностей
- Названия сущностей в ваших примерных данных должны соответствовать глобальной модели данных
- Используйте описания и связи в качестве руководства

**Если его нет:**
Покажите предупреждение, но продолжайте:

"Примечание: Глобальная модель данных еще не определена. Я создам структуры сущностей на основе спецификации секции, но для согласованности между секциями рассмотрите сначала запуск `/data-model`."

## Step 3: Analyze the Specification

Прочитайте и проанализируйте `product/sections/[section-id]/spec.md`, чтобы понять:

- Какие сущности данных подразумеваются пользовательскими потоками?
- Какие поля/свойства нужны каждой сущности?
- Какие примерные значения были бы реалистичными и полезными для дизайна?
- Какие действия можно выполнить над каждой сущностью? (Они становятся пропсами колбэков)

**Если существует глобальная модель данных:** Сопоставьте спецификацию с моделью данных. Используйте те же названия сущностей и обеспечивайте согласованность.

## Step 4: Present Data Structure

Представьте вашу предлагаемую структуру данных пользователю простым языком. Нетехнические пользователи должны понимать, как организуются их данные.

**Если используется глобальная модель данных:**

"Основываясь на спецификации для **[Section Title]** и вашей глобальной модели данных, вот как я организую данные:

**Сущности (из вашей модели данных):**

- **[Entity1]** — [Описание из модели данных]
- **[Entity2]** — [Описание из модели данных]

**Данные, специфичные для секции:**

[Любые дополнительные данные, специфичные для потребностей UI этой секции]

**Что вы можете делать:**

- Просматривать, редактировать и удалять [сущности]
- [Другие ключевые действия из спецификации]

**Примерные данные:**

Я создам [X] реалистичных записей [Entity1] с разнообразным контентом, чтобы ваши дизайны экранов выглядели реальными.

Имеет ли смысл эта структура? Какие-нибудь корректировки?"

**Если нет глобальной модели данных:**

"Основываясь на спецификации для **[Section Title]**, вот как я предлагаю организовать ваши данные:

**Модели данных:**

- **[Entity1]** — [Одно предложение, объясняющее, что это представляет]
- **[Entity2]** — [Одно предложение объяснения]

**Как они соединяются:**

[Объясните связи простыми терминами]

**Что вы можете делать:**

- Просматривать, редактировать и удалять [сущности]
- [Другие ключевые действия из спецификации]

**Примерные данные:**

Я создам [X] реалистичных записей [Entity1] с разнообразным контентом, чтобы ваши дизайны экранов выглядели реальными.

Имеет ли смысл эта структура для вашего продукта? Какие-нибудь корректировки?"

Используйте инструмент AskUserQuestion, если есть неясности относительно того, какие данные нужны.

## Step 5: Generate the Data File

После одобрения пользователем структуры создайте `product/sections/[section-id]/data.json` с:

- **Секцией `_meta`** - Описаниями каждой модели данных и их связей простым языком (отображаются в UI)
- **Реалистичными примерными данными** - Используйте правдоподобные имена, даты, описания и т.д.
- **Разнообразным контентом** - Смешивайте короткий и длинный текст, разные статусы и т.д.
- **Граничными случаями** - Включите хотя бы один пустой массив, одно длинное описание и т.д.
- **Структурой, дружественной к TypeScript** - Используйте согласованные имена полей и типы

### Required `_meta` Structure

Каждый data.json ДОЛЖЕН включать объект `_meta` на верхнем уровне с:

1. **`models`** - Объект, где каждый ключ - это имя модели, а значение - описание простым языком
2. **`relationships`** - Массив строк, объясняющих, как модели соединяются друг с другом

Пример структуры:

```json
{
  "_meta": {
    "models": {
      "invoices": "Каждый счет представляет собой счет, который вы отправляете клиенту за выполненную работу.",
      "lineItems": "Позиции - это отдельные услуги или продукты, перечисленные в каждом счете."
    },
    "relationships": [
      "Каждый Счет содержит одну или несколько Позиций (разбивка платежей)",
      "Счета отслеживают, какому Клиенту они принадлежат, через поле clientName"
    ]
  },
  "invoices": [
    {
      "id": "inv-001",
      "invoiceNumber": "INV-2024-001",
      "clientName": "Acme Corp",
      "clientEmail": "billing@acme.com",
      "total": 1500.00,
      "status": "sent",
      "dueDate": "2024-02-15",
      "lineItems": [
        { "description": "Web Design", "quantity": 1, "rate": 1500.00 }
      ]
    }
  ]
}
```

Описания `_meta` должны:
- Использовать простой, нетехнический язык
- Объяснять, что представляет каждая модель в контексте продукта пользователя
- Описывать связи в терминах "содержит", "принадлежит", "связывает" и т.д.
- **Соответствовать описаниям глобальной модели данных, если она существует**

Данные должны напрямую поддерживать пользовательские потоки и требования к UI в спецификации.

## Step 6: Generate TypeScript Types

После создания data.json сгенерируйте `product/sections/[section-id]/types.ts` на основе структуры данных.

### Type Generation Rules

1. **Выводите типы из значений примерных данных:**
   - Строки → `string`
   - Числа → `number`
   - Булевы → `boolean`
   - Массивы → `TypeName[]`
   - Объекты → Создайте именованный интерфейс

2. **Используйте типы объединения для полей статуса/перечисления:**

   - Если поле типа `status` имеет известные значения, используйте объединение: `'draft' | 'sent' | 'paid' | 'overdue'`

   - Основывайтесь на спецификации и разнообразии в примерных данных

3. **Создайте интерфейс Props для основного компонента:**
   - Включите данные как проп (например, `invoices: Invoice[]`)
   - Включите опциональные пропсы колбэков для каждого действия (например, `onDelete?: (id: string) => void`)

4. **Используйте согласованные имена сущностей:**
   - Если существует глобальная модель данных, используйте те же имена сущностей
   - Это обеспечивает согласованность между секциями

Пример types.ts:

```typescript
// =============================================================================
// Data Types
// =============================================================================

export interface LineItem {
  description: string
  quantity: number
  rate: number
}

export interface Invoice {
  id: string
  invoiceNumber: string
  clientName: string
  clientEmail: string
  total: number
  status: 'draft' | 'sent' | 'paid' | 'overdue'
  dueDate: string
  lineItems: LineItem[]
}

// =============================================================================
// Component Props
// =============================================================================

export interface InvoiceListProps {
  /** The list of invoices to display */
  invoices: Invoice[]
  /** Called when user wants to view an invoice's details */
  onView?: (id: string) => void
  /** Called when user wants to edit an invoice */
  onEdit?: (id: string) => void
  /** Called when user wants to delete an invoice */
  onDelete?: (id: string) => void
  /** Called when user wants to archive an invoice */
  onArchive?: (id: string) => void
  /** Called when user wants to create a new invoice */
  onCreate?: () => void
}
```

### Naming Conventions

- Используйте PascalCase для имен интерфейсов: `Invoice`, `LineItem`, `InvoiceListProps`

- Используйте camelCase для имен свойств: `clientName`, `dueDate`, `lineItems`

- Интерфейс Props должен называться `[SectionName]Props` (например, `InvoiceListProps`)

- Добавьте комментарии JSDoc для пропсов колбэков, чтобы объяснить, когда они вызываются

- **Соответствуйте именам сущностей из глобальной модели данных, если она существует**

## Step 7: Confirm and Next Steps

Сообщите пользователю:

"Я создал два файла для **[Section Title]**:

1. `product/sections/[section-id]/data.json` - Примерные данные с [X] записями

2. `product/sections/[section-id]/types.ts` - Интерфейсы TypeScript для безопасности типов

Типы включают:

- `[Entity]` - Основной тип данных
- `[SectionName]Props` - Интерфейс пропсов для компонента (включает колбэки для [список действий])

Когда будете готовы, запустите `/design-screen` для создания дизайна экрана для этой секции."

## Important Notes

- Генерируйте реалистичные, правдоподобные примерные данные - не "Lorem ipsum" или "Test 123"
- Включайте 5-10 примерных записей для основных сущностей (достаточно, чтобы показать реалистичный список)
- Включайте граничные случаи: пустые массивы, длинный текст, разные статусы
- Держите имена полей ясными и дружественными к TypeScript (camelCase)
- Структура данных должна напрямую соответствовать пользовательским потокам спецификации
- Всегда генерируйте types.ts вместе с data.json
- Пропсы колбэков должны покрывать все действия, упомянутые в спецификации
- **Используйте имена сущностей из глобальной модели данных для согласованности между секциями**
